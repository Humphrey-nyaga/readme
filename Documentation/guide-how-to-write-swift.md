# How to write Swift

The intention of this document is to guide how we should write Swift at Nodes. The document should be considered as work-in-progress and PR's with corrections etc. are much appreciated.

## Table of Contents

- [Language](#language)
- [Code Organization](#code-organization)
- [Naming](#naming)
- [Spacing](#spacing)
- [Comments](#comments)
- [Documentation](#documentation)
- [Classes and Structures](#classes-and-structures)
- [Type Inference](#type-inference)
- [Access Control](#access-control)
- [Generics](#generics)
- [Extensions](#extensions)
- [Syntactic Sugar](#syntactic-sugar)
- [Parentheses](#parentheses)
- [Functions vs Methods](#functions-vs-methods)
- [Use of Self](#use-of-self)
- [Golden Path](#golden-path)
- [Xcode Warnings](#xcode-warnings)
- [Outcommented Code](#outcommented-code)
- [SwiftLint](#swiftlint)
- [Miscellaneous](#miscellaneous)
- [License](#license)



## Language

Use US English spelling to match Apple's API.

## Code Organization

Use marks ( `// MARK: -` and `// MARK:`) and comments throughout your code to keep things separated and well-organized.

## Naming

Descriptive and consistent naming makes software easier to read and understand. Use the Swift naming conventions described in the [API Design Guidelines](	https://swift.org/documentation/api-design-guidelines/). Some key takeaways:

- Method names and variables must start with a lower case letter. 
- Classes, structs, and type names should be capitalized. 
- The name of a variable should be enough to tell another programmer what that variable does. Don't use variable names such as `number`, `a`, `b`, `x`, `button`, `label`, etc. 
- To adhere to the Swift 3 syntax, all enum cases will be lowerCamelCase and not UpperCamelCase as before.
- An [initialism](https://en.wiktionary.org/wiki/initialism) should be kept uppercase consistently (e.g.: `class AvatarURLTag`, `var avatarURL`.) unless the name starts with it, then we keep it lowercase (e.g. `var url: URL`)

## Spacing

- Indent using 4 spaces. (Xcode pref. -> Text Editing -> Indentation and then make sure it is set to "Spaces" and width = 4.)
- Long lines should be wrapped at **100** characters. (Xcode pref -> Text Editing -> Page guide at column 100.)
- Avoid trailing whitespaces at the ends of lines. (Xcode pref. -> Text Editing and make sure "Automatically trim trail…" and "Including whitespace-only lines" checked.)
- Add a single newline character at the end of each file. (Xcode will do this initially for you.)

Tip: Setup Xcode to help you follow these guidelines.

To achieve a column width of max 100 consider how you call and declare functions, how you use `guard` etc. For example:

```swift
guard let a = test, let b = test2 else {

}
```

Could be written:

```swift
guard
    let a = test,
    let b = test2
else {

}
```

Similarly a function like:

```swift
func products(for category: Category, on worker: Worker) throws -> Future<[Product]> {

}
```

Could be written:

```swift
func products(
    for category: Category,
    on worker: Worker
) throws -> Future<[Product]> {

}
```

## Comments

When they are needed, use comments to explain why a particular piece of code does something. Comments must be kept up-to-date or deleted.

Avoid block comments inline with code, as the code should be as self-documenting as possible. _Exception: This does not apply to those comments used to generate documentation._

## Documentation

At least all public interfaces should be documented, but it is also preferred that internal (and private) interfaces gets documented as well. The preferred style of documentation blocks follows the Swift API's and are as follows (both for one-line and multi-line documentation):

```Swift
/// Shows all users.
///
/// - Parameter request: The performed request.
/// - Returns: A list of users.
/// - Throws: Error if db is not setup correctly.
```

This documentation can be auto-generated by Xcode by placing the cursor on the declaration (being function, object etc.) and by clicking Editor -> Structure -> Add Documentation or `⌥⌘/`.

## Classes and Structures

Remember, structs have [value semantics](https://developer.apple.com/library/mac/documentation/Swift/Conceptual/Swift_Programming_Language/ClassesAndStructures.html#//apple_ref/doc/uid/TP40014097-CH13-XID_144). Use structs for things that do not have an identity. An array that contains `[a, b, c]` is really the same as another array that contains `[a, b, c]` and they are completely interchangeable. It doesn't matter whether you use the first array or the second, because they represent the exact same thing. That's why arrays are structs.

Classes have [reference semantics](https://developer.apple.com/library/mac/documentation/Swift/Conceptual/Swift_Programming_Language/ClassesAndStructures.html#//apple_ref/doc/uid/TP40014097-CH13-XID_145). Use classes for things that do have an identity or a specific life cycle. You would model a person as a class because two person objects are two different things. Just because two people have the same name and birthdate, doesn't mean they are the same person. But the person's birthdate would be a struct because a date of 3 March 1950 is the same as any other date object for 3 March 1950. The date itself doesn't have an identity.

## Type Inference

Prefer compact code and let the compiler infer the type for constants or variables of single instances. Type inference is also appropriate for small (non-empty) arrays and dictionaries. When required, specify the specific type.

In situations where type inference is not possible and there's an option to pass in the type in a function call, having the type on the constant/variable declaration is preferred.

**Preferred**:
```swift
let foo: MyType = try someFunction()
```

**Not preferred:**
```swift
let foo = try someFunction(MyType.self)
```

## Access Control

It is preferred to limit scope as much as possible by using access modifiers. That said, redunant access modifiers should be avoided.

## Generics

Generic type parameters should be descriptive, upper camel case names. When a type name doesn't have a meaningful relationship or role, use a traditional single uppercase letter such as `T`, `U`, or `V`.

## Extensions

When adding a protocol implementation to a class or struct, add a separate extension for the protocol methods and use the `//MARK: -` comment. This increases the readability of the code.

```Swift
final class Post: Model {
    // ...
}

// MARK: - Preparation
extension Post: Preparation {
    // Preparation methods ...
}
```
## Syntactic Sugar

Prefer the shortcut versions of type declarations over the full generics syntax.

**Preferred:**

```swift
var deviceModels: [String]
var employees: [Int: String]
var faxNumber: Int?
```

**Not Preferred:**

```swift
var deviceModels: Array<String>
var employees: Dictionary<Int, String>
var faxNumber: Optional<Int>
```

## Parentheses

Parentheses around conditionals are not required and should be omitted.

## Functions vs Methods

Free functions, which aren't attached to a class or type, should be used sparingly. When possible, prefer to use a method instead of a free function. This aids in readability and discoverability.

Free functions are most appropriate when they aren't associated with any particular type or instance.

## Use of Self

For conciseness, avoid using `self` since Swift does not require it to access an object's properties or invoke its methods.

Use self only when required by the compiler (in `@escaping` closures, or in initializers to disambiguate properties from arguments). In other words, if it compiles without `self` then omit it.

## Golden Path

When coding with conditionals, the left-hand margin of the code should be the "golden" or "happy" path. That is, don't nest `if` statements. Multiple return statements are OK. The `guard` statement is built for this.

**Preferred:**

```swift
func computeFFT(context: Context?, inputData: InputData?) throws -> Frequencies {

  guard let context = context else { 
    throw FFTError.noContext 
  }
  guard let inputData = inputData else { 
    throw FFTError.noInputData 
  }

  // use context and input to compute the frequencies

  return frequencies
}
```

**Not Preferred:**

```swift
func computeFFT(context: Context?, inputData: InputData?) throws -> Frequencies {

  if let context = context {
    if let inputData = inputData {
      // use context and input to compute the frequencies

      return frequencies
    } else {
      throw FFTError.noInputData
    }
  } else {
    throw FFTError.noContext
  }
}
```

## Xcode Warnings

Try to keep the number of warnings in a project to 0. If there is a really good reason for a warning to be there, consider adding a comment explaining why it is acceptabel to be there (temporarily).

## Outcommented Code

Don't leave out commented code. Or if you feel you really need to, also leave a comment saying why that code is there and why it might be needed again. But in general, delete commented out code. We use git, so you can always get old code from there.

## SwiftLint

[SwiftLint](https://github.com/realm/SwiftLint) is a tool (a linter) to help us make sure we follow the agreed guidelines. It can be installed by running (assuming `brew` is installed):

```
brew install swiftlint
```

Then move the `.swiftlint.yml` configuration from this repo into the root of your project directory. Run SwiftLint by calling:

```
swiftlint
```

If the configuration filed has been placed correctly, it will automatically pick it up and apply it. The terminal should now show you any violations you might have made. The SwiftLint repo also has documentation on how to integrate SwiftLint into Xcode, making the IDE display the errors and warnings on the specific lines they are occurring.

Depending on the project, you may want to commit the SwiftLint configuration file. The configuration file will change over time to accommodate our needs as we go along.

## Miscellaneous

- Use `let` and not `var` wherever possible.
- Avoid force-unwrapping optionals, instead use a `if let` or similar. Alternatively use optional chaining `myVar?.someFuncToCallIfMyVarIsNotNil()`.

## License

This guide was heavily inspired by [Ray Wenderlich's Swift style guide](https://github.com/raywenderlich/swift-style-guide) and the [Nodes iOS Playbook](https://github.com/nodes-ios/Playbook/blob/master/styleguide.md). The copyright notice from the Ray Wenderlich Swift style guide repo is added below:

```
This style guide is available under the MIT license:

Original work Copyright (c) 2016-2017 Razeware LLC
Modified work Copyright (c) 2016 Nodes Vapor

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
```

